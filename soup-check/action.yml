name: 'Dependency Review Assignment'
description: 'Assign reviewers based on dependency changes'
inputs:
  project-type:
    description: 'The type of project (e.g., web, flutter or * for both). DEPRECATED'
    required: true
    default: '*'
  soup-approvers:
    description: 'The GitHub usernames of the soup approvers to assign as reviewers'
    required: true
    default: 'nasirky'
  non-semver-dependencies:
    description: 'A list of dependencies that do not follow semantic versioning'
    required: false
    default: ''
  ignore-files-list:
    description: 'A list of dependencies files to ignore'
    required: false
    default: ''
runs:
  using: "composite"
  steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Copy scripts
      shell: bash
      run: cp $GITHUB_ACTION_PATH/scripts/* . && chmod +x compare_deps.sh
    - name: Compare Dependencies
      id: compare
      shell: bash
      run: |
        FILES=$(git ls-files | grep -E "package\.json$|pubspec\.yaml$" || true)
        echo "Found files:"
        echo "$FILES"

        IGNORE_LIST="${{ inputs.ignore-files-list }}"
        if [[ -n "$IGNORE_LIST" ]]; then
          for IGNORE_FILE in $(echo "$IGNORE_LIST" | tr ',' '\n'); do
            FILES=$(echo "$FILES" | grep -v -F -x "$IGNORE_FILE")
          done
        fi

        echo "Ignore List: $IGNORE_LIST"
        if [[ -n "$IGNORE_LIST" ]]; then
          echo "Files after applying ignore list:"
          echo "$FILES"
        fi

        HAS_CHANGED=false
        for PKG_FILE in $FILES; do
          result=$(./compare_deps.sh ${{ github.event.pull_request.base.sha }} "$PKG_FILE" "${{ inputs.non-semver-dependencies }}")
          echo "$result"
          status_line=$(echo "$result" | tail -n 1)
          [[ "$status_line" != "nothing" ]] && HAS_CHANGED=true
          echo "Status Line: $status_line ($HAS_CHANGED)"
        done

        echo "has-changed=$HAS_CHANGED" >> $GITHUB_OUTPUT
    - name: Assign Reviewers
      if: ${{ steps.compare.outputs.has-changed == 'true' }}
      uses: actions/github-script@v7
      env:
        SOUP_APPROVERS: ${{ inputs.soup-approvers }}
      with:
        script: |
          const soupApprovers = process.env.SOUP_APPROVERS || "";

          const pr = context.payload.pull_request;
          if (!pr)
            core.setFailed('No pull request found.');

          const prAuthor = pr.user.login;
          const reviewerList = soupApprovers.split(',').map(r => r.trim()).filter(r => r && r !== prAuthor);

          if (reviewerList.length === 0) {
            core.info('No reviewers to assign.');
            return;
          }

          const { data: reviews } = await github.rest.pulls.listReviews({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: pr.number,
          });

          const approvedOrRequested = [...new Set(reviews.map(r => r.user.login))];
          const reviewersToAdd = reviewerList.filter(r => !approvedOrRequested.includes(r));

          core.info(`SOUP Approver List: ${reviewerList.join(', ')}`);
          core.info(`Already assigned reviewers: ${approvedOrRequested.join(', ')}`);

          if (reviewersToAdd.length > 0)
            core.info(`Reviewers to add: ${reviewersToAdd.join(', ')}`);

          if (reviewersToAdd.length > 0) {
            await github.rest.pulls.requestReviewers({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              reviewers: reviewersToAdd,
            });
            core.info(`Assigned New Reviewers: ${reviewersToAdd.join(', ')}`);
          } else {
            core.info('All SOUP Reviewers are already assigned.');
          }

    - name: Require Approval From Assigned Reviewer
      if: ${{ steps.compare.outputs.has-changed == 'true' }}
      uses: actions/github-script@v7
      env:
        SOUP_APPROVERS: ${{ inputs.soup-approvers }}
      with:
        script: |
          const soupApprovers = process.env.SOUP_APPROVERS || "";
          
          const pr = context.payload.pull_request;
          if (!pr)
            core.setFailed('No pull request found.');
          
          const prAuthor = pr.user.login;
          const reviewerList = soupApprovers.split(',').map(r => r.trim()).filter(r => r && r !== prAuthor);
          
          if (reviewerList.length === 0) {
            core.info('No reviewers to assign.');
            return;
          }

          const reviews = await github.rest.pulls.listReviews({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: pr.number,
          });

          const latestReviews = {};
          for (const review of reviews.data) {
            if (review.state !== "DISMISSED") {
              latestReviews[review.user.login] = review.state;
            }
          }

          const approvers = Object.entries(latestReviews)
            .filter(([user, state]) => state === 'APPROVED')
            .map(([user]) => user);

          if (approvers.length > 0)
            core.info(`Approved by: ${approvers.join(', ')}`);
          else
            core.info('No approvals yet.');

          const approved = reviewerList.some(r => latestReviews[r] === 'APPROVED');
          if (!approved)
            core.setFailed(`At least one of these reviewers must approve: ${soupApprovers}`);
          else
            core.info('Approval requirement satisfied.');
